<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ByteStream: IPC::ByteStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ByteStream
   &#160;<span id="projectnumber">15.1.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>IPC</b></li><li class="navelem"><a class="el" href="classIPC_1_1ByteStream.html">ByteStream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classIPC_1_1ByteStream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IPC::ByteStream Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Clase contenedora para una secuencia de bytes, utilizada para el envio y recepcion de datos a traves de un socket, a una seccion de memoria compartida, escritura y lectura en un archivo, etc.  
 <a href="classIPC_1_1ByteStream.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ByteStream_8h_source.html">ByteStream.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5d1b14f11442e4d7893ab9415b17eb2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPC_1_1ByteStream.html#a5d1b14f11442e4d7893ab9415b17eb2e">ByteStream</a> (size_t capacidad=0)</td></tr>
<tr class="memdesc:a5d1b14f11442e4d7893ab9415b17eb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construye un <a class="el" href="classIPC_1_1ByteStream.html" title="Clase contenedora para una secuencia de bytes, utilizada para el envio y recepcion de datos a traves ...">ByteStream</a> con capacidad <em>capacidad</em>.  <a href="#a5d1b14f11442e4d7893ab9415b17eb2e">More...</a><br/></td></tr>
<tr class="separator:a5d1b14f11442e4d7893ab9415b17eb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd070133485ce6b2324960820e53a5c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPC_1_1ByteStream.html#aecd070133485ce6b2324960820e53a5c">ByteStream</a> (const byte_t *stream, size_t tamanio)</td></tr>
<tr class="memdesc:aecd070133485ce6b2324960820e53a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construye un <a class="el" href="classIPC_1_1ByteStream.html" title="Clase contenedora para una secuencia de bytes, utilizada para el envio y recepcion de datos a traves ...">ByteStream</a> a partir de una copia de los datos apuntados por <em>stream</em>, cuyo tamanio es <em>tamanio</em>. La capacidad del objeto creado es <em>tamanio</em>.  <a href="#aecd070133485ce6b2324960820e53a5c">More...</a><br/></td></tr>
<tr class="separator:aecd070133485ce6b2324960820e53a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcf681d3b0dd8be6b1767a8ad494321"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPC_1_1ByteStream.html#a5bcf681d3b0dd8be6b1767a8ad494321">ByteStream</a> (const <a class="el" href="classIPC_1_1ByteStream.html">ByteStream</a> &amp;aCopiar)</td></tr>
<tr class="memdesc:a5bcf681d3b0dd8be6b1767a8ad494321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constuctor copia.  <a href="#a5bcf681d3b0dd8be6b1767a8ad494321">More...</a><br/></td></tr>
<tr class="separator:a5bcf681d3b0dd8be6b1767a8ad494321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114c0edf82f57bc6f2a789ddba956057"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPC_1_1ByteStream.html#a114c0edf82f57bc6f2a789ddba956057">asignarStream</a> (const byte_t *stream, size_t tamanio)</td></tr>
<tr class="memdesc:a114c0edf82f57bc6f2a789ddba956057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo que elimina el contenido previo y le asigna una copia de los datos apuntados por <em>stream</em>, cuyo tamanio es <em>tamanio</em>. La capacidad del objeto sera <em>tamanio</em> si su capacidad previa era menor a <em>tamanio</em>, o se mantendra con la misma capacidad si era mayor o igual.  <a href="#a114c0edf82f57bc6f2a789ddba956057">More...</a><br/></td></tr>
<tr class="separator:a114c0edf82f57bc6f2a789ddba956057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba8b5c90b2172f77c2091508e2945fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPC_1_1ByteStream.html#aaba8b5c90b2172f77c2091508e2945fd">redimensionar</a> (size_t nuevaCapacidad)</td></tr>
<tr class="memdesc:aaba8b5c90b2172f77c2091508e2945fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo para redimensionar la capacidad del stream. Los datos se conservan. En caso de que <em>nuevaCapacidad</em> sea menor al tamanio ocupado en el stream, el stream queda en estado lleno y los datos que quedaron afuera de la capacidad se pierden.  <a href="#aaba8b5c90b2172f77c2091508e2945fd">More...</a><br/></td></tr>
<tr class="separator:aaba8b5c90b2172f77c2091508e2945fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027d27a87c0ccfeba3762bce4e5d3369"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPC_1_1ByteStream.html#a027d27a87c0ccfeba3762bce4e5d3369">insertarDatos</a> (const void *dato, size_t tamanioDato)</td></tr>
<tr class="memdesc:a027d27a87c0ccfeba3762bce4e5d3369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo para insertar datos al final del stream (es decir, desde la ultima posicion en donde se escribio). Si el stream no tiene suficiente capacidad libre, se redimensiona para poder insertar el nuevo dato.  <a href="#a027d27a87c0ccfeba3762bce4e5d3369">More...</a><br/></td></tr>
<tr class="separator:a027d27a87c0ccfeba3762bce4e5d3369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23f8d983af6f9b1341279ed6a7fa064"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab23f8d983af6f9b1341279ed6a7fa064"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPC_1_1ByteStream.html#ab23f8d983af6f9b1341279ed6a7fa064">vaciarStream</a> ()</td></tr>
<tr class="memdesc:ab23f8d983af6f9b1341279ed6a7fa064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo que vacia los datos del stream. <br/></td></tr>
<tr class="separator:ab23f8d983af6f9b1341279ed6a7fa064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40829754bdc6e9152b5d4261aeb154e2"><td class="memItemLeft" align="right" valign="top">const byte_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPC_1_1ByteStream.html#a40829754bdc6e9152b5d4261aeb154e2">obtenerStream</a> () const </td></tr>
<tr class="memdesc:a40829754bdc6e9152b5d4261aeb154e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo que obtiene el stream para consulta, no modificacion.  <a href="#a40829754bdc6e9152b5d4261aeb154e2">More...</a><br/></td></tr>
<tr class="separator:a40829754bdc6e9152b5d4261aeb154e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e32436f7fb7cc2e08000cec0ddbc70f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPC_1_1ByteStream.html#a3e32436f7fb7cc2e08000cec0ddbc70f">getTamanioOcupado</a> () const </td></tr>
<tr class="memdesc:a3e32436f7fb7cc2e08000cec0ddbc70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo para obtener el tamanio ocupado.  <a href="#a3e32436f7fb7cc2e08000cec0ddbc70f">More...</a><br/></td></tr>
<tr class="separator:a3e32436f7fb7cc2e08000cec0ddbc70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9d9a7903c176896c63b5fb250fe4f4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPC_1_1ByteStream.html#acc9d9a7903c176896c63b5fb250fe4f4">getCapacidadTotal</a> () const </td></tr>
<tr class="memdesc:acc9d9a7903c176896c63b5fb250fe4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo para obtener la capacidad maxima.  <a href="#acc9d9a7903c176896c63b5fb250fe4f4">More...</a><br/></td></tr>
<tr class="separator:acc9d9a7903c176896c63b5fb250fe4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f33177a245fdeb14444ab3eb64ae0f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPC_1_1ByteStream.html#a56f33177a245fdeb14444ab3eb64ae0f">getCapacidadRestante</a> () const </td></tr>
<tr class="memdesc:a56f33177a245fdeb14444ab3eb64ae0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo para obtener la capacidad restante.  <a href="#a56f33177a245fdeb14444ab3eb64ae0f">More...</a><br/></td></tr>
<tr class="separator:a56f33177a245fdeb14444ab3eb64ae0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6723f0434fc39a61b06a11bb4ba2f1e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPC_1_1ByteStream.html#a6723f0434fc39a61b06a11bb4ba2f1e5">estaLleno</a> () const </td></tr>
<tr class="memdesc:a6723f0434fc39a61b06a11bb4ba2f1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metodo para consultar si el stream esta lleno.  <a href="#a6723f0434fc39a61b06a11bb4ba2f1e5">More...</a><br/></td></tr>
<tr class="separator:a6723f0434fc39a61b06a11bb4ba2f1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7f8c3442a440a198323c3d8d3716ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f7f8c3442a440a198323c3d8d3716ec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPC_1_1ByteStream.html#a8f7f8c3442a440a198323c3d8d3716ec">~ByteStream</a> ()</td></tr>
<tr class="memdesc:a8f7f8c3442a440a198323c3d8d3716ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a8f7f8c3442a440a198323c3d8d3716ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Clase contenedora para una secuencia de bytes, utilizada para el envio y recepcion de datos a traves de un socket, a una seccion de memoria compartida, escritura y lectura en un archivo, etc. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5d1b14f11442e4d7893ab9415b17eb2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IPC::ByteStream::ByteStream </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacidad</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construye un <a class="el" href="classIPC_1_1ByteStream.html" title="Clase contenedora para una secuencia de bytes, utilizada para el envio y recepcion de datos a traves ...">ByteStream</a> con capacidad <em>capacidad</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacidad</td><td>Capacidad del stream, en bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aecd070133485ce6b2324960820e53a5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IPC::ByteStream::ByteStream </td>
          <td>(</td>
          <td class="paramtype">const byte_t *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tamanio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construye un <a class="el" href="classIPC_1_1ByteStream.html" title="Clase contenedora para una secuencia de bytes, utilizada para el envio y recepcion de datos a traves ...">ByteStream</a> a partir de una copia de los datos apuntados por <em>stream</em>, cuyo tamanio es <em>tamanio</em>. La capacidad del objeto creado es <em>tamanio</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Puntero a los datos que se guardaran en la instancia creada </td></tr>
    <tr><td class="paramname">tamanio</td><td>Tamanio total de los datos apuntados por <em>stream</em> en bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5bcf681d3b0dd8be6b1767a8ad494321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IPC::ByteStream::ByteStream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIPC_1_1ByteStream.html">ByteStream</a> &amp;&#160;</td>
          <td class="paramname"><em>aCopiar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constuctor copia. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aCopiar</td><td>Instancia a copiar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a114c0edf82f57bc6f2a789ddba956057"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPC::ByteStream::asignarStream </td>
          <td>(</td>
          <td class="paramtype">const byte_t *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tamanio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo que elimina el contenido previo y le asigna una copia de los datos apuntados por <em>stream</em>, cuyo tamanio es <em>tamanio</em>. La capacidad del objeto sera <em>tamanio</em> si su capacidad previa era menor a <em>tamanio</em>, o se mantendra con la misma capacidad si era mayor o igual. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Puntero a los datos que se guardaran en la instancia </td></tr>
    <tr><td class="paramname">tamanio</td><td>Tamanio total de los datos apuntados por @ stream en bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6723f0434fc39a61b06a11bb4ba2f1e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IPC::ByteStream::estaLleno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo para consultar si el stream esta lleno. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> si el stream esta lleno </dd></dl>

</div>
</div>
<a class="anchor" id="a56f33177a245fdeb14444ab3eb64ae0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t IPC::ByteStream::getCapacidadRestante </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo para obtener la capacidad restante. </p>
<dl class="section return"><dt>Returns</dt><dd>La capacidad restante, en bytes </dd></dl>

</div>
</div>
<a class="anchor" id="acc9d9a7903c176896c63b5fb250fe4f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t IPC::ByteStream::getCapacidadTotal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo para obtener la capacidad maxima. </p>
<dl class="section return"><dt>Returns</dt><dd>La capacidad maxima, en bytes </dd></dl>

</div>
</div>
<a class="anchor" id="a3e32436f7fb7cc2e08000cec0ddbc70f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t IPC::ByteStream::getTamanioOcupado </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo para obtener el tamanio ocupado. </p>
<dl class="section return"><dt>Returns</dt><dd>El tamanio ocupado, en bytes </dd></dl>

</div>
</div>
<a class="anchor" id="a027d27a87c0ccfeba3762bce4e5d3369"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPC::ByteStream::insertarDatos </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dato</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tamanioDato</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo para insertar datos al final del stream (es decir, desde la ultima posicion en donde se escribio). Si el stream no tiene suficiente capacidad libre, se redimensiona para poder insertar el nuevo dato. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dato</td><td>Puntero a los datos a insertar </td></tr>
    <tr><td class="paramname">tamanioDato</td><td>Tamanio de los datos a insertar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40829754bdc6e9152b5d4261aeb154e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const byte_t * IPC::ByteStream::obtenerStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo que obtiene el stream para consulta, no modificacion. </p>
<dl class="section return"><dt>Returns</dt><dd>Puntero a los datos guardados en el stream </dd></dl>

</div>
</div>
<a class="anchor" id="aaba8b5c90b2172f77c2091508e2945fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IPC::ByteStream::redimensionar </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nuevaCapacidad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metodo para redimensionar la capacidad del stream. Los datos se conservan. En caso de que <em>nuevaCapacidad</em> sea menor al tamanio ocupado en el stream, el stream queda en estado lleno y los datos que quedaron afuera de la capacidad se pierden. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nuevaCapacidad</td><td>Tamanio nuevo del stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/martin/Repositorios/Bibliotecas_Cpp/ByteStream/src/<a class="el" href="ByteStream_8h_source.html">ByteStream.h</a></li>
<li>/home/martin/Repositorios/Bibliotecas_Cpp/ByteStream/src/ByteStream.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 8 2015 12:03:58 for ByteStream by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
